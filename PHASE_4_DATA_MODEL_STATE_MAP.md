# PHASE 4 – DATA MODEL & STATE MAP

**Strictly Descriptive Documentation: No Design Opinions**

This document describes APPSIERRA's internal data structures and state management as they exist in the codebase.

---

## 4.1 CORE DATA STRUCTURES / MODELS

### 4.1.1 Trading Records (data/schema.py)

#### TradeRecord (Lines 19-73)
**File:** `data/schema.py:19`

**What it represents:**
A complete trading cycle from entry to exit, capturing all financial metrics, timing, and market context for a single position.

**Purpose in the system:**
TradeRecord is the persistent record of every completed or open trade. It serves as the single source of truth for trade history, P&L calculations, and statistical analysis. Each record represents one position (long or short) in a specific symbol, tracked from the moment of entry until exit or current time if still open.

**Key fields and their meanings:**

| Field | Type | Meaning |
|-------|------|---------|
| `id` | Optional[int] | Primary key, auto-generated by database |
| `symbol` | str | Trading symbol (e.g., "MESZ24", "ES", "NQ") |
| `side` | str | Position direction: "LONG" or "SHORT" |
| `qty` | int | Position size in contracts |
| `mode` | str | Trading mode: "SIM" or "LIVE" (indexed for filtering) |
| `entry_time` | datetime | When position was opened (indexed) |
| `entry_price` | float | Average fill price on entry |
| `exit_time` | Optional[datetime] | When position closed (None if open, indexed) |
| `exit_price` | Optional[float] | Average fill price on exit |
| `is_closed` | bool | True when position fully exited (indexed) |
| `realized_pnl` | Optional[float] | Final P&L in dollars after close |
| `commissions` | Optional[float] | Total commission cost for trade |
| `r_multiple` | Optional[float] | Risk-reward multiple (profit/risk) |
| `mae` | Optional[float] | Maximum Adverse Excursion: worst unrealized loss during trade |
| `mfe` | Optional[float] | Maximum Favorable Excursion: best unrealized profit during trade |
| `efficiency` | Optional[float] | Capture ratio: realized_pnl / mfe (how much of max profit was captured) |
| `entry_vwap` | Optional[float] | Volume-weighted average price at entry time |
| `entry_cum_delta` | Optional[float] | Cumulative delta at entry (buying/selling pressure) |
| `exit_vwap` | Optional[float] | VWAP at exit time |
| `exit_cum_delta` | Optional[float] | Cumulative delta at exit |
| `account` | Optional[str] | Trading account identifier (e.g., "Sim1", "120005") |

**Database indexes:**
- `idx_trade_mode_exit_time`: Composite index on (mode, exit_time) for fast mode-filtered queries
- `idx_trade_closed_mode`: Composite index on (is_closed, mode) for open position queries

**How it's used:**
- Written by `TradeManager.record_close_trade()` in `services/trade_service.py:155`
- Read by `StatsService.calculate_stats()` in `services/stats_service.py` for all statistical metrics
- Queried by Panel 3 for displaying trade history and performance metrics
- Used for SIM balance calculation: `sim_balance = starting_balance + sum(realized_pnl where mode='SIM')`

---

#### OrderRecord (Lines 75-95)
**File:** `data/schema.py:75`

**What it represents:**
An individual order execution event. Each OrderRecord tracks one order from submission through its lifecycle until filled, cancelled, or rejected.

**Purpose in the system:**
OrderRecord provides granular order tracking for auditing and trade reconstruction. Unlike TradeRecord which represents complete positions, OrderRecord captures every order action, including partial fills and bracket orders (OCO pairs for stop-loss and profit targets).

**Key fields and their meanings:**

| Field | Type | Meaning |
|-------|------|---------|
| `id` | int | Primary key |
| `order_id` | str | ServerOrderID from DTC (indexed for fast lookup) |
| `symbol` | str | Trading symbol (indexed) |
| `side` | str | "BUY" or "SELL" |
| `qty` | int | Total order quantity |
| `price` | float | Limit/stop price (0 for market orders) |
| `filled_qty` | int | Quantity actually filled |
| `filled_price` | Optional[float] | Average fill price |
| `status` | str | "PENDING", "FILLED", "CANCELLED", "REJECTED" |
| `mode` | str | "SIM" or "LIVE" (indexed) |
| `timestamp` | datetime | Order creation time (indexed) |
| `account` | Optional[str] | Trading account |

**How it's used:**
- Written by `TradeManager.record_order()` in `services/trade_service.py`
- Read during trade reconstruction when correlating orders to positions
- Used by historical fill analysis to validate trade entry/exit prices
- Queried for order history in Panel 2 (live trading panel)

---

#### AccountBalance (Lines 97-109)
**File:** `data/schema.py:97`

**What it represents:**
A point-in-time snapshot of account equity and available funds.

**Purpose in the system:**
AccountBalance records historical balance data from DTC Type 600 messages (ACCOUNT_BALANCE_UPDATE). It provides an audit trail of balance changes and enables equity curve visualization.

**Key fields and their meanings:**

| Field | Type | Meaning |
|-------|------|---------|
| `id` | int | Primary key |
| `account_id` | str | Account identifier (indexed) |
| `balance` | float | Total account equity in dollars |
| `mode` | str | "LIVE" or "SIM" (indexed) |
| `timestamp` | datetime | When snapshot was taken (indexed) |

**How it's used:**
- Written by `MessageRouter._on_balance_update()` when Type 600 messages arrive
- Read for equity curve generation (not currently implemented)
- Provides historical balance verification
- Currently not heavily used in UI, but available for future analytics

---

### 4.1.2 DTC Protocol Models (services/dtc_schemas.py)

These are Pydantic models that validate and normalize incoming DTC messages from Sierra Chart.

#### OrderUpdate (Lines 111-315)
**File:** `services/dtc_schemas.py:111`
**DTC Type:** 301

**What it represents:**
A real-time update about an order's state from Sierra Chart. This is the most critical DTC message type, as it carries all order lifecycle events: submission, acceptance, fills (partial or complete), cancellations, and rejections.

**Purpose in the system:**
OrderUpdate messages are the primary mechanism for tracking trade execution. Every state change of an order generates a Type 301 message. The system uses these to detect position entry/exit, update live P&L, track MAE/MFE, and determine when trades are complete.

**Key fields and their meanings:**

| Field | Type | Meaning |
|-------|------|---------|
| `Type` | int | Always 301 for OrderUpdate |
| `ServerOrderID` | str | Unique order ID assigned by Sierra Chart |
| `ClientOrderID` | Optional[str] | User-assigned order ID (if provided) |
| `TradeAccount` | Optional[str] | Account this order belongs to (used for mode detection) |
| `Symbol` | str | Trading symbol |
| `Exchange` | Optional[str] | Exchange identifier |
| `BuySell` | int | 1 = BUY, 2 = SELL |
| `OrderType` | int | 1=Market, 2=Limit, 3=Stop, 4=StopLimit, 5=MIT |
| `OrderStatus` | int | 0=Unspec, 1=New, 2=Submitted, 3=PendingCancel, 4=Open, 5=PendingReplace, 6=Canceled, 7=Filled, 8=Rejected, 9=PartiallyFilled |
| `OrderUpdateReason` | Optional[int] | Why this update was sent (0-9 reason codes) |
| Quantity aliases | int | Multiple field names for same data: `OrderQuantity`, `Quantity`, `TotalQuantity` |
| Price aliases | float | Multiple field names: `Price1`, `Price`, `LimitPrice`, `StopPrice` |
| `FilledQuantity` | Optional[int] | How many contracts filled so far |
| `RemainingQuantity` | Optional[int] | Contracts still unfilled |
| `AverageFillPrice` | Optional[float] | Average price of all fills |
| `LastFillPrice` | Optional[float] | Most recent fill price |
| `LastFillQuantity` | Optional[int] | Size of most recent fill |
| `LastFillDateTime` | Optional[float] | Unix timestamp of last fill |
| Position extremes | float | `HighDuringPosition`, `LowDuringPosition`: price extremes while position was open |
| Text aliases | str | Status messages: `InfoText`, `TextMessage`, `FreeFormText`, `RejectText` |
| `LatestTransactionDateTime` | Optional[float] | Unix timestamp of this update |
| `RequestID` | Optional[int] | Links to original request (0 = unsolicited update) |

**Field aliases explained:**
Sierra Chart sends different field names depending on version and context. For example, quantity might arrive as "OrderQuantity", "Quantity", or "TotalQuantity". The model uses Pydantic `Field(alias=...)` to accept all variants, and provides helper methods like `get_quantity()` that coalesce these fields with priority ordering.

**Helper methods:**
- `get_side()`: Returns "Buy" or "Sell" string
- `get_quantity()`: Returns first non-None quantity field
- `get_price()`: Returns first non-None price field
- `get_avg_fill_price()`: Returns average fill price, falling back to LastFillPrice
- `is_terminal()`: True if status is Filled, Canceled, or Rejected
- `is_fill_update()`: True if FilledQuantity > 0 or LastFillQuantity present
- `get_timestamp()`: Returns LatestTransactionDateTime or LastFillDateTime
- `get_text()`: Returns first non-empty text field (InfoText, TextMessage, etc.)

**How it's used:**
- Received in `DTCClientJSON._on_ready_read()` (core/data_bridge.py)
- Parsed and validated by `parse_dtc_message()` in `services/dtc_schemas.py`
- Routed to `MessageRouter._on_order_update()` (core/message_router.py)
- Processed by Panel 2 for live position tracking
- Used by `TradeManager` to detect position open/close events
- Analyzed by `OrderLedgerBuilder` to reconstruct complete order history

---

#### PositionUpdate (Lines 339-390)
**File:** `services/dtc_schemas.py:339`
**DTC Type:** 306

**What it represents:**
Current state of an open position in Sierra Chart.

**Purpose in the system:**
PositionUpdate provides a snapshot of existing positions. However, Sierra Chart's DTC server does NOT send unsolicited Type 306 messages in most configurations. They only arrive in response to explicit POSITION_REQUEST (Type 500) messages. APPSIERRA primarily tracks positions via Type 301 order fills rather than relying on Type 306.

**Key fields:**

| Field | Type | Meaning |
|-------|------|---------|
| `Type` | int | Always 306 |
| `RequestID` | Optional[int] | Links to position request |
| `TotalNumberMessages` | Optional[int] | How many position updates in this batch |
| `MessageNumber` | Optional[int] | Sequence number in batch |
| `Symbol` | str | Position symbol |
| `Exchange` | Optional[str] | Exchange |
| `TradeAccount` | Optional[str] | Account (for mode detection) |
| `Quantity` | Optional[float] | Net position: positive = long, negative = short |
| `AveragePrice` | Optional[float] | Average entry price |
| `OpenProfitLoss` | Optional[float] | Unrealized P&L |
| `HighPriceDuringPosition` | Optional[float] | Highest price reached since entry |
| `LowPriceDuringPosition` | Optional[float] | Lowest price reached since entry |

**How it's used:**
- Received after sending POSITION_REQUEST (Type 500)
- Processed by `MessageRouter._on_position_update()`
- Used for mode detection: if TradeAccount doesn't match current mode, triggers mode drift warning
- Used to sync internal position state after reconnect or app restart
- NOT the primary mechanism for position tracking (Type 301 fills are primary)

---

#### TradeAccountResponse (Lines 392-409)
**File:** `services/dtc_schemas.py:392`
**DTC Type:** 401

**What it represents:**
Response to a TRADE_ACCOUNTS_REQUEST, enumerating all available trading accounts in Sierra Chart.

**Key fields:**

| Field | Type | Meaning |
|-------|------|---------|
| `Type` | int | Always 401 |
| `RequestID` | int | Links to request |
| `TradeAccount` | str | Account identifier (e.g., "Sim1", "120005") |

**How it's used:**
- Sent by Sierra Chart after TRADE_ACCOUNTS_REQUEST (Type 400)
- Processed by `MessageRouter._on_trade_account()`
- Used to populate account dropdown/selection in UI
- Logged to TradeManager for account tracking

---

#### AccountBalanceUpdate (Lines 411-442)
**File:** `services/dtc_schemas.py:411`
**DTC Type:** 600

**What it represents:**
Current account balance and equity information from Sierra Chart.

**Key fields:**

| Field | Type | Meaning |
|-------|------|---------|
| `Type` | int | Always 600 |
| `RequestID` | Optional[int] | 0 for unsolicited updates |
| `TotalAccountBalance` | Optional[float] | Alias for total equity |
| `CashBalance` | Optional[float] | Cash available |
| `AccountValue` | Optional[float] | Total account value |
| `NetLiquidatingValue` | Optional[float] | Liquidation value |
| `AvailableFunds` | Optional[float] | Funds available for trading |
| `BalanceAvailableForNewPositions` | Optional[float] | Buying power |
| `MarginRequirement` | Optional[float] | Current margin used |
| `OpenPositionsProfitLoss` | Optional[float] | Unrealized P&L across all positions |
| `TradeAccount` | Optional[str] | Account identifier |

**Field priority for balance calculation:**
The system uses `get_balance()` method which coalesces in this order:
1. `TotalAccountBalance`
2. `CashBalance`
3. `AccountValue`
4. `NetLiquidatingValue`
5. `AvailableFunds`

**How it's used:**
- Received after ACCOUNT_BALANCE_REQUEST (Type 601) or as unsolicited update
- Processed by `MessageRouter._on_balance_update()`
- Updates `StateManager.live_balance` (for LIVE accounts)
- Does NOT affect `StateManager.sim_balance` (SIM balance is calculated from trade records)
- Displayed in Panel 1 (balance/account panel)
- Stored in `AccountBalance` database table for historical tracking

---

### 4.1.3 Derived Metrics

#### Trade Statistics (services/stats_service.py)

**What it represents:**
Aggregated performance metrics calculated from TradeRecord history.

**Computed metrics (15+ values):**

| Metric | Calculation | Meaning |
|--------|-------------|---------|
| `total_trades` | COUNT(*) | Number of closed trades |
| `winning_trades` | COUNT(WHERE realized_pnl > 0) | Number of profitable trades |
| `losing_trades` | COUNT(WHERE realized_pnl < 0) | Number of losing trades |
| `total_pnl` | SUM(realized_pnl) | Net profit/loss across all trades |
| `avg_pnl` | AVG(realized_pnl) | Average P&L per trade |
| `win_rate` | winning_trades / total_trades | Percentage of winning trades |
| `profit_factor` | SUM(winning_pnl) / ABS(SUM(losing_pnl)) | Ratio of gross profit to gross loss |
| `largest_win` | MAX(realized_pnl) | Best single trade |
| `largest_loss` | MIN(realized_pnl) | Worst single trade |
| `avg_mae` | AVG(mae) | Average maximum adverse excursion |
| `avg_mfe` | AVG(mfe) | Average maximum favorable excursion |
| `avg_efficiency` | AVG(efficiency) | Average capture ratio |
| `max_drawdown` | MAX cumulative loss | Largest peak-to-trough equity decline |
| `max_runup` | MAX cumulative profit | Largest equity increase |
| `current_streak` | Consecutive wins/losses | Current winning or losing streak |
| `expectancy` | (win_rate × avg_win) - (loss_rate × avg_loss) | Expected value per trade |

**How they're calculated:**
- Computed by `StatsService.calculate_stats()` in `services/stats_service.py`
- Input: TradeRecord query filtered by `mode` and `timeframe`
- Uses raw SQL aggregations for performance
- Results cached with 5-second TTL to prevent redundant queries

**Caching mechanism:**
- Cache key: `(timeframe, mode)` tuple
- TTL: 5 seconds
- Invalidated on new trade close or mode change
- In-memory dictionary: `_stats_cache`

**How it's used:**
- Displayed in Panel 3 (statistics panel)
- Provides trader performance feedback
- Used for risk management decisions
- Segregated by mode: SIM stats never mixed with LIVE stats

---

#### Order Ledger (services/dtc_ledger.py)

**What it represents:**
Aggregated view of order lifecycle built from multiple Type 301 messages.

**Three data structures:**

1. **OrderLedgerEntry** (Terminal state summary)
   - Groups all Type 301 messages by `ServerOrderID`
   - Keeps highest priority status (Filled > Canceled > Open)
   - Tracks first/last update timestamps
   - Stores position extremes (high/low prices)
   - Duration calculation: last_update - first_update

2. **FillEntry** (Chronological fill events)
   - One entry per fill event
   - Fields: `timestamp`, `quantity`, `price`, `symbol`, `server_order_id`
   - Sorted by timestamp for sequential fill analysis

3. **OrderSnapshot** (Latest state)
   - Most recent Type 301 message for each order
   - Used for displaying current order status

**How it's built:**
- `OrderLedgerBuilder.build()` processes list of Type 301 messages
- Groups by `ServerOrderID`
- Applies terminal state ranking: Filled=5, Rejected=5, Canceled=5, PartiallyFilled=4, Open=3
- Extracts fill events from messages with `LastFillQuantity`
- Returns tuple: `(list[OrderLedgerEntry], list[FillEntry], list[OrderSnapshot])`

**How it's used:**
- Historical order reconstruction after reconnect
- Audit trail for regulatory compliance
- Position reconciliation when DTC connection lost
- Debugging order execution issues

---

### 4.1.4 Configuration Structures

#### Trading Specifications (config/trading_specs.py)

**What it represents:**
Static configuration for futures contracts traded on the platform.

**Structure:**
```python
TRADING_SPECS = {
    "ES": {
        "tick_size": 0.25,
        "tick_value": 12.50,
        "display_name": "E-mini S&P 500"
    },
    "MES": {
        "tick_size": 0.25,
        "tick_value": 1.25,
        "display_name": "Micro E-mini S&P 500"
    },
    # ... more symbols
}
```

**How it's used:**
- P&L calculations: `pnl = price_change / tick_size * tick_value * qty`
- Commission calculations
- Risk calculations (dollar value per tick)
- UI formatting (decimal places)

---

#### Settings (config/settings.py)

**What it represents:**
Application-wide configuration loaded from environment variables or config.json.

**Key settings groups:**

1. **DTC Connection:**
   - `DTC_HOST`: Sierra Chart IP (default: 127.0.0.1)
   - `DTC_PORT`: DTC port (default: 11099)
   - `DTC_USERNAME`: Authentication username
   - `DTC_PASSWORD`: Authentication password

2. **Trading Mode:**
   - `TRADING_MODE`: "DEBUG", "SIM", or "LIVE"
   - `LIVE_ACCOUNT`: Account ID for live trading (e.g., "120005")

3. **Database:**
   - `DB_URL`: PostgreSQL connection string (primary)
   - `POSTGRES_DSN`: Fallback PostgreSQL connection
   - Falls back to SQLite: `sqlite:///data/appsierra.db`
   - Last resort: In-memory SQLite (warning logged)

4. **Debug Flags:**
   - `DEBUG_MODE`: Enable verbose logging
   - `DEBUG_DTC`: Log DTC protocol messages
   - `DEBUG_DATA`: Log payload contents
   - `DEBUG_CORE`: Log core system events
   - `DEBUG_UI`: Log UI events
   - `DEBUG_NETWORK`: Log network events

**How it's loaded:**
- Environment variables parsed first
- `config.json` overrides env vars if present
- `_env_str()`, `_env_int()`, `_env_bool()` helper functions with defaults

**How it's used:**
- Imported globally: `from config.settings import DTC_HOST, TRADING_MODE`
- Used throughout the application for behavior control
- Mode detection logic uses `TRADING_MODE` and account naming patterns

---

## 4.2 WHERE STATE LIVES

### 4.2.1 StateManager (core/state_manager.py)

**File:** `core/state_manager.py`

**What it is:**
Central runtime registry for application state. Single instance created at app startup, accessible globally via `get_state_manager()`.

**State it owns:**

| State Variable | Type | Meaning |
|----------------|------|---------|
| `sim_balance` | float | Current simulated trading balance (starts at $10,000) |
| `live_balance` | float | Current live account balance (from DTC Type 600) |
| `current_mode` | str | Active trading mode: "DEBUG", "SIM", or "LIVE" |
| `current_account` | str | Active account identifier (e.g., "Sim1", "120005") |
| `_active_position` | Optional[dict] | Currently open position (None if flat) |
| `_mode_history` | list[dict] | All mode switches with timestamps |
| `_start_time` | datetime | App startup time |

**Signals (Blinker):**
- `balanceChanged`: Emitted when `sim_balance` or `live_balance` changes
- `modeChanged`: Emitted when `current_mode` or `current_account` changes

**Who reads from it:**
- Panel 1: Displays current balance based on mode
- Panel 2: Checks mode for position entry/exit
- Panel 3: Filters statistics by current mode
- TradeManager: Records mode in TradeRecord
- MessageRouter: Validates incoming messages match current mode

**Who writes to it:**
- `MessageRouter._on_balance_update()`: Updates `live_balance` when Type 600 arrives
- `SimBalanceManager.update_sim_balance()`: Recalculates `sim_balance` from database trades
- `StateManager.set_mode()`: Changes `current_mode` and `current_account`
- `TradeManager`: Updates `_active_position` on entry/exit

**Under what conditions:**
- Balance updates: Every Type 600 message from DTC (live_balance), after every trade close (sim_balance)
- Mode changes: User clicks mode button in UI, mode drift detected, or on startup
- Position updates: Every Type 301 fill message that opens or closes a position

**Thread safety:**
StateManager is NOT thread-safe. All access must occur on Qt main thread. MessageRouter uses `marshal_to_qt_thread()` to ensure this.

---

### 4.2.2 SimBalanceManager (core/sim_balance.py)

**File:** `core/sim_balance.py`

**What it is:**
Account-scoped persistence and calculation for simulated trading balances.

**State it owns:**
- **In-memory:** Current calculated SIM balance
- **On-disk:** JSON files in `data/sim_balance_{account}.json`

**File format:**
```json
{
  "account": "Sim1",
  "starting_balance": 10000.0,
  "_schema_version": "1.0",
  "_saved_at_utc": "2024-11-13T10:30:00Z"
}
```

**Calculation method:**
```
current_sim_balance = starting_balance + SUM(realized_pnl FROM TradeRecord WHERE mode='SIM' AND account=current_account)
```

**Ledger-based approach:**
SIM balance is NOT stored as a single mutable value. It is always calculated from trade history, ensuring consistency even after app crashes or database changes.

**Who reads from it:**
- `StateManager.__init__()`: Loads SIM balance at startup
- Panel 1: Displays SIM balance when in SIM mode

**Who writes to it:**
- `SimBalanceManager.update_sim_balance()`: Recalculates after each trade close
- `SimBalanceManager.reset_sim_balance()`: Resets to starting amount (user action)

**When it's written:**
- After every closed SIM trade (triggered by `TradeManager.record_close_trade()`)
- On app startup (loads from JSON or defaults to $10,000)
- When user manually resets balance

**Persistence strategy:**
Uses atomic JSON writes via `save_json_atomic()` in `utils/atomic_persistence.py`. Write-to-temp-file then atomic-rename pattern ensures file is never corrupted, even if process crashes mid-write.

---

### 4.2.3 Panel State (panels/)

**What it is:**
Each Panel (Panel1, Panel2, Panel3) is a Qt widget that owns its own UI state.

#### Panel 1 (panels/panel1.py) - Balance & Account Display

**State it owns:**
- Selected account (dropdown selection)
- Display mode (SIM/LIVE toggle)
- Cached balance value for rendering

**Who reads:** Main UI rendering loop
**Who writes:** User interaction (dropdown change), DTC balance updates
**Persistence:** None (ephemeral, reconstructed from StateManager on startup)

---

#### Panel 2 (panels/panel2.py) - Live Trading / Position Management

**State it owns:**
- Current position (symbol, side, qty, entry price, entry time)
- Live P&L calculation
- Position extremes (MAE/MFE updates every tick)
- Chart data (price history for graph)

**Data structure (internal dict):**
```python
{
    "symbol": "MESZ24",
    "side": "LONG",
    "qty": 5,
    "entry_price": 5998.50,
    "entry_time": datetime(...),
    "mode": "SIM",
    "account": "Sim1"
}
```

**Who reads:** Panel 2 rendering, TradeManager
**Who writes:**
- `Panel2.on_order_update()`: Updates on Type 301 fills
- `Panel2._on_close_trade()`: Clears on exit
- `Panel2._update_live_pnl()`: Recalculates P&L every 100ms

**Persistence:** JSON file `data/panel2_state_{mode}_{account}.json`
**When persisted:** After every position state change (entry, exit, qty change)
**When loaded:** On app startup via `_load_panel_state()`

---

#### Panel 3 (panels/panel3.py) - Statistics & Trade History

**State it owns:**
- Cached statistics dictionary
- Selected timeframe filter ("All", "Today", "This Week", "This Month")
- Selected mode filter (follows StateManager.current_mode)

**Who reads:** Panel 3 UI rendering
**Who writes:**
- `Panel3._refresh_stats()`: Updates stats every 2 seconds
- `Panel3.on_timeframe_change()`: User changes timeframe dropdown

**Persistence:** None (statistics always computed from database on demand)

---

### 4.2.4 Global Registries

#### AppState Singleton (core/app_state.py)

**What it is:**
Global accessor for the StateManager instance. Ensures only one StateManager exists per app session.

**Pattern:**
```python
_state_manager: Optional[StateManager] = None

def get_state_manager() -> StateManager:
    global _state_manager
    if _state_manager is None:
        _state_manager = StateManager()
    return _state_manager
```

**Who reads:** Every module that needs state
**Who writes:** Only written once on first call to `get_state_manager()`

---

#### Message Registry (services/dtc_schemas.py)

**What it is:**
Mapping of DTC message type codes to Pydantic model classes.

**Structure:**
```python
DTC_MESSAGE_REGISTRY = {
    301: OrderUpdate,
    304: HistoricalOrderFillResponse,
    306: PositionUpdate,
    401: TradeAccountResponse,
    600: AccountBalanceUpdate,
}
```

**Who reads:** `parse_dtc_message()` function
**Who writes:** Never (static constant)

---

### 4.2.5 Cached Data

#### Stats Cache (services/stats_service.py)

**What it is:**
In-memory dictionary caching computed statistics to avoid redundant database queries.

**Structure:**
```python
_stats_cache: dict[tuple, tuple[dict, float]] = {}
# Key: (timeframe, mode)
# Value: (stats_dict, expiry_timestamp)
```

**TTL:** 5 seconds
**Invalidation:**
- TTL expiry (automatic)
- New trade close (explicit via `invalidate_stats_cache()`)
- Mode change (explicit)

**Who reads:** `StatsService.calculate_stats()`
**Who writes:** Same function after database query
**Thread safety:** Accessed only from Qt main thread

---

#### Order Ledger Cache (services/dtc_ledger.py)

**What it is:**
In-memory storage of all Type 301 messages grouped by ServerOrderID.

**Structure:**
```python
# Internal to OrderLedgerBuilder
_orders: dict[str, list[OrderUpdate]] = {}
# Key: ServerOrderID
# Value: List of all Type 301 messages for that order
```

**Lifetime:** Per-session (cleared on app restart)
**Who reads:** `OrderLedgerBuilder.build()`
**Who writes:** `OrderLedgerBuilder.add_order_update()`

---

## 4.3 PERSISTENCE

### 4.3.1 Database (SQLAlchemy + PostgreSQL/SQLite)

**File:** `data/db_engine.py`

**What gets stored:**

| Table | Primary Use | Retention |
|-------|-------------|-----------|
| `traderecord` | All trades (open and closed) | Indefinite |
| `orderrecord` | All order events | Indefinite |
| `accountbalance` | Balance snapshots | Indefinite |

**Connection configuration:**

1. **Primary:** PostgreSQL via `POSTGRES_DSN` environment variable
2. **Fallback:** SQLite file at `data/appsierra.db`
3. **Last resort:** In-memory SQLite (logs warning, no persistence)

**Engine settings:**
- `pool_pre_ping=True`: Tests connections before use (prevents stale connection errors)
- `echo=DEBUG_MODE`: Logs all SQL when debug enabled

**When it's written:**

- **TradeRecord:**
  - On position close: Full record written with all metrics
  - Updates: When position still open but metrics change (rare)

- **OrderRecord:**
  - On every Type 301 message (if configured for order logging)
  - Currently OPTIONAL: controlled by `TradeManager.record_order()` call sites

- **AccountBalance:**
  - On every Type 600 message (ACCOUNT_BALANCE_UPDATE)
  - Throttled to max once per second by MessageRouter

**By whom:**

- `TradeManager.record_close_trade()`: Writes TradeRecord
- `TradeManager.record_order()`: Writes OrderRecord
- `MessageRouter._on_balance_update()`: Writes AccountBalance

**Thread safety:**
`TradeManager` uses a threading lock (`_lock = threading.Lock()`) around all database writes. This prevents race conditions when multiple Type 301 messages arrive in rapid succession.

---

### 4.3.2 JSON Files (Atomic Persistence)

**File:** `utils/atomic_persistence.py`

**What gets stored:**

| File Pattern | Contents | Purpose |
|-------------|----------|---------|
| `data/panel2_state_{mode}_{account}.json` | Panel 2 position state | Resume open positions after restart |
| `data/sim_balance_{account}.json` | SIM starting balance | Calculate current SIM balance |
| `config/config.json` | User configuration overrides | Override environment variables |

**Atomic write pattern:**
```python
1. Write to temporary file: {path}.tmp
2. fsync() to ensure disk flush
3. Atomic rename: {path}.tmp → {path}
4. Result: File is never partially written (crash-safe)
```

**Schema versioning:**
Every JSON file includes:
```json
{
  "_schema_version": "1.0",
  "_saved_at_utc": "2024-11-13T10:30:00Z",
  ... actual data ...
}
```

**When loaded:**
- **Startup:** Panel 2 loads `panel2_state_*.json` to restore open positions
- **Startup:** `SimBalanceManager` loads `sim_balance_*.json`
- **Startup:** Settings loads `config.json`

**On demand:**
- Panel state: Only loaded once at startup, then kept in memory

**Error handling:**
- Missing file: Treated as "no saved state", returns defaults
- Corrupted JSON: Logs error, returns defaults
- Schema version mismatch: Logs warning, attempts to use data anyway

---

### 4.3.3 JSONL (Line-Delimited JSON)

**File:** `core/persistence.py`

**What it is:**
Append-only log files where each line is a complete JSON object.

**What gets stored:**

| File | Contents | Purpose |
|------|----------|---------|
| `~/.sierra_pnl_monitor/equity_curve.jsonl` | Time-series equity snapshots | Equity curve visualization (not currently active) |
| `~/.sierra_pnl_monitor/events.jsonl` | Application events | Audit trail (not currently active) |

**Write pattern:**
```python
def append_jsonl(path: str, obj: dict):
    with open(path, 'a') as f:
        f.write(json.dumps(obj) + '\n')
```

**Read pattern:**
```python
def read_jsonl(path: str) -> list[dict]:
    with open(path, 'r') as f:
        return [json.loads(line) for line in f if line.strip()]
```

**Advantages:**
- Minimal memory: No need to load entire file to append
- Sequential writes: Fast for logging
- Human-readable: Each line is valid JSON

**Current usage:**
JSONL infrastructure exists but is NOT heavily used in current codebase. Primarily used by helper tools, not by main application.

---

### 4.3.4 Migrations (data/migrations/)

**What it is:**
SQL scripts that modify database schema between versions.

**Example:** `data/migrations/add_efficiency_column.sql`
```sql
ALTER TABLE traderecord ADD COLUMN IF NOT EXISTS efficiency REAL;
```

**When applied:**
- On app startup via `_run_migrations()` in `data/db_engine.py`
- Applied in alphabetical order
- Each migration is idempotent (safe to run multiple times)

**Migration tracking:**
Currently NO tracking of which migrations have been applied. All migrations must be written to be safe for repeated execution (e.g., `ADD COLUMN IF NOT EXISTS`).

---

### 4.3.5 Data Initialization

**Startup sequence (from MainWindow.__init__):**

1. `init_db()`: Create all tables from SQLModel metadata
2. `_run_migrations()`: Apply any schema changes
3. `get_state_manager()`: Create StateManager singleton
4. `SimBalanceManager.load()`: Load SIM balance from JSON
5. `TradeManager.calculate_sim_balance_from_db()`: Recalculate from trades (ledger-based)
6. `Panel2._load_panel_state()`: Restore open positions
7. `DTCClientJSON.connect()`: Establish DTC connection
8. `_request_initial_data()`: Request accounts, balance, positions, orders, fills

**First run behavior:**
- If no database: Creates empty SQLite file
- If no `sim_balance_*.json`: Defaults to $10,000 starting balance
- If no `panel2_state_*.json`: Starts with no open positions
- If no `config.json`: Uses environment variables or hardcoded defaults

---

## SUMMARY: Data Flow Example

**Scenario:** User enters a long position in MES, holds it, then exits.

1. **Entry:**
   - User clicks "Buy 5 MES" in Panel 2
   - Order sent to Sierra Chart via DTC
   - Type 301 message arrives: `OrderStatus=7 (Filled)`, `BuySell=1 (Buy)`, `FilledQuantity=5`
   - `MessageRouter._on_order_update()` processes message
   - Extracts `TradeAccount` → Detects mode = "SIM", account = "Sim1"
   - Routes to `Panel2.on_order_update()`
   - Panel 2 updates internal position dict: `{"symbol": "MESZ24", "side": "LONG", "qty": 5, "entry_price": 5998.50}`
   - Panel 2 saves to `data/panel2_state_SIM_Sim1.json`
   - `TradeManager` optionally writes OrderRecord to database

2. **During position:**
   - Every 100ms, Panel 2 calculates live P&L from current market price
   - Tracks MAE (worst unrealized loss) and MFE (best unrealized profit)
   - Updates displayed in Panel 2 UI
   - NO database writes (only in-memory)

3. **Exit:**
   - User clicks "Close Position"
   - Exit order sent, Type 301 arrives: `OrderStatus=7`, `BuySell=2 (Sell)`, `FilledQuantity=5`
   - Panel 2 detects exit, calculates final metrics
   - Calls `TradeManager.record_close_trade()` with:
     ```python
     {
       "symbol": "MESZ24",
       "side": "LONG",
       "qty": 5,
       "entry_price": 5998.50,
       "exit_price": 6001.75,
       "entry_time": datetime(...),
       "exit_time": datetime(...),
       "realized_pnl": 40.63,
       "mae": -6.25,
       "mfe": 43.75,
       "efficiency": 0.93,
       "mode": "SIM",
       "account": "Sim1"
     }
     ```
   - `TradeManager` writes TradeRecord to database
   - `TradeManager` calls `SimBalanceManager.update_sim_balance()`
   - `SimBalanceManager` recalculates: `10000 + SUM(realized_pnl) = 10040.63`
   - `StateManager.sim_balance` updated to 10040.63
   - `balanceChanged` signal emitted
   - Panel 1 updates balance display
   - Panel 3 invalidates stats cache
   - Panel 3 fetches new stats from database (now includes this trade)
   - Panel 2 clears position state, deletes `panel2_state_SIM_Sim1.json`

**Result:** Trade is now permanently recorded in database, balance is updated, statistics reflect the new trade, and UI shows updated values.

---

**End of Phase 4 Documentation**
